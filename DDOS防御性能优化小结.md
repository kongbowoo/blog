> 性能优化，简言之，主要是为了消除处理瓶颈，加速转发能力，提高吞吐性能。
 
#一、如何找到影响性能的瓶颈？
性能分析（profiling），最简单的方法就是计算一段流程所用的时间差，在各个平台下都有相应的库函数或图形化的工具，如Visual Studio里的WPF工具集、Intel的VTune、IBM的Rational工具集等。
在分布式防火墙RMI多核平台下，现行的做法是在每个报文都做处理的流程中，计算某段代码或某些函数的执行过程使用了多少个cycle数（时钟周期），从而进行比较，找出占用cycle数最多的那段代码或函数，也称之为热点（hotspots），在此基础上，再针对特定的代码和函数进行细化比较分析，找到最终影响性能的热点，针对热点进行优化。
注：RMI的协处理器中有一个寄存器$25，可设置相应的事件类型（如63: Always increment (cycle count)）记录代码执行使用的cycle数，有兴趣的可以翻阅一下RMI的手册。
 
#二、如何进行性能优化？
在我理解范围内，有以下四个方面的优化：
##1. 流程上的优化
通常处理流程的优化是最能提高性能的方式，它是以业务为基础，调整报文处理过程的优先级，使得报文在整个流程中走的更短。
（1）如果有功能开关，需要判断是否使能后再进入处理流程。
（2）如果有计数，需要判断计数数量是否有效，然后再进入流程处理，如静态黑白名单。
（3）如果某处理流程仅对某一特殊应用层协议处理，则在调用此接口前需要先判断此报文是否匹配该应用层协议，如判断TCP的DNS报文。
（4）降低接口间的藕合性，尽可能提供功能专一的接口，一来便于调整流程，二来接口内部的变动不会影响外部的流程处理。
（5）充分利用缓存信息，比如说报文每次都要通过接口索引查找接口配置表，通过静态局部变量在接口中缓存接口配置表，可以减少查表、加解锁操作，效果明显。
（6）反弹流程提前，抛弃传统SMBUF的概念，在SPI4收到IP报文后，直接进入防范处理流程。
 
##2. 算法上的优化
在实际的开发工作中，我们大多数进行的是工程开发，算法研究虽不会常常遇到，但是一个合适而优秀的算法可以大幅提高性能，我用几个实例来说明一下：
###（1）哈希算法
哈希算法的主要作用是在保证数据的分布均匀，在报文处理流程中无时不刻不存在，如查找会话、查找源IP节点等，一个优秀的哈希算法的计算应该是快速并使得数据的冲突均匀化的。
常用的哈希操作是通过移位、加法、取模或查表综合进行的，在产品的早期过程使用的是CRC32算法，它是典型的查表算法，指令较多、占用内存、速度慢，最后替换为现在的TLU算法，主要通过靠移位和加法操作，运算速度得到很大提高，替换后单CPU的转发处理能力提高了近200M（60字节SYN报文），已经相当可观。
###（2）模式匹配算法
模式匹配算法常用于报文深度检测（DPI）过程中，通常可以理解为字符串匹配过程，分为单模式匹配算法和多模式匹配算法，在实际应用可以根据算法复杂度、内存占用情况、匹配效率来进行选择。
①单模式匹配算法：即在源字符串中查找到一个特定模式字符串，类似于strstr操作，其算法复杂度最高，有常见的KMP算法、BM算法，它们可以根据一定的字符跳跃规则来提高查找效率。
在应用中，我们查找HTTP报文中的URL字段、查找SIP报文中的branch字段等查找单个字符串过程，都可以应用。
②多模式匹配算法：给出若干个模式字符串，在源字符串中查找是否有某个匹配，常见的算法有AC算法、Wu-manber算法，以及相应一些变种算法，它们的基本原理是通过对模式集的预处理或构造状态自动机的方式，在遍历源字符串的过程中，保证指针不回溯，通过一定的字符跳跃规则进行匹配。
在动态指纹查找过程中，需要在报文中查找多个字符串进行匹配，原有的方式由于开发进度的问题，直接使用了strstr进行遍历查找，算法复杂度为O（n^3），并且会随着模式字符串的增多，性能线性下降；后期优化通过采用Wu-manber算法，算法复杂度为O（n^2），性能提高了30%，CPU利用率大大降低，并且性能不再受模式字符串个数的限制。
###（3）检验和算法
报文检验和算法的基本原理是16位累积相加，消除高16位后取反的过程。
在报文处理流程中，经常要改变IP和TCP报文的某些字段，同时更新检验和，通常的做法是修改一个字段，马上进行校验和的调整，比如在构造一个SYN报文的反弹SYN-ACK报文过程中，调整校验和的次数达到了6次，通过检验和算法的研究，以及在反弹SYN-ACk报文中需要固定更新的字段，后期仅需要调整两次校验和，反弹流程使用的cycle数由原来2400左右降低到了1400左右，至少降低了1/3的消耗。
注：校验和优化可以参考RFC1141文档，其中讨论了IP的TTL更新时，调整校验和的一种快速算法。
 
##3. 语句上的优化
语句上的优化，更多的是细节上的调整和变动，积少成多，同样可以提高产品的性能。
（1）尽可能的使用局部变量，少使用全局变量；如果共享内存空间充许的话，使用共享内存来传递全局数据。
（2）if语句中优先考虑较多情况下的分支，而将较少情况放在else判断中。
（3）如果有多个判断条件，将符合条件最多的情况放在前面，Case语句同样的处理。
（4）常用的基础函数可以使用汇编来实现，如memset操作，当然这样的优化也会降低可维护性和阅读性。
（5）在循环判断条件中，将需要计算的数值提前到循环前进行计算，比如类似strlen的计算。
（6）尽量避免使用乘法、除法和取模操作，乘法可以采用左移位操作，除法采用右移位操作，取模采用位与操作；
（7）保证数据对齐。
（8）接口的参数不宜过多（最多不超过8个），过多的参数会导致压栈出栈频繁，同样影响性能，可以考虑采用结构体传参的方式，依靠指针进行数据传递。
（9）去除不必要的调试语句和计数。
 
##4. 编译上的优化

###（1）On优化
产品和CBB默认GCC编译是O3优化，并且强制不进行内联（便于后期补丁的制作），O3优化编译器做了很多的工作，在O2的基础上，开启了内联和寄存器重命名功能。
###（2）强制内联优化
产品中默认编译选择中是不进行内联操作的，但一些小函数，规模不大，功能固定的，可以使用__attribute__((always_inline))进行修饰，减少函数的调用。
###（3）段优化
在汇编链接过程中，默认指令段为.text，其指令的分布顺序依据链接顺序而分布，在理论上讲通过设置接口的段属性，将产品的指令和CBB相关的指令强制设置在同一指令段（section）中，提高指令缓存的命中率，由于研究不够深入，最终没有达到预期的效果，这是有一点小遗憾。
###（4）编译和链接优化
通常我们在链接LIB库的过程中，默认的情况下，所有的代码段和数据段都会链接到同一section内，通过在LIB库编译阶段（如gcc）使用-fffunction-sections和-fdata-sections，编译器在生成OBJ时会将每个全局变量和函数各自放在自己的section内，而后在链接阶段（如ld）使用--gc-section可以只引用需要的数据段和代码段。这样处理好处不言而喻，减少了数据段和代码段的空间，在程序运行的过程中也可以减少cache miss。
               
> 注：更多的GCC优化选项和编译选项可以参考《GCC The Complete Reference》。

#三、何时进行性能的优化？
性能优化最关键的是需要一个稳定、功能可靠的版本做为基线版本，一来可以看出来优化效果，二来不会受到流程变动导致性能的此消彼长，所以有人说过“在条件不成熟的情况下贸然进行优化是程序设计中所有罪恶源泉”。优化虽然是一个长期的过程，但要适可而止，只要达到或接近了预期目标就可以告一段落，因为在优化的过程中，会引入很多例如重启、功能缺失等大大小小的问题。
上面是我在近期优化性能过后，能想到的一些方法和思路，与大家分享一下，性能优化是一门很深的学问，我在这里也仅仅是浅尝辄止、管中窥豹，如果大家有问题或是好的提议，可以继续讨论。
 
————2012年2月20号DDOS防御性能优化小结
